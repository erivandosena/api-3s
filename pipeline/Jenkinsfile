#!/usr/bin/env groovy

def getSecretsConfig(){
  return [[
    engineVersion: 2, 
    path: 'secret/3s/config', 
    secretValues: [
      [envVar: 'PG_USER', isRequired: false, vaultKey: 'pg_user'], 
      [envVar: 'PG_PASSWORD', isRequired: false, vaultKey: 'pg_password'],
      [envVar: 'PG_USER_ROOT', isRequired: false, vaultKey: 'pg_user_root'],
      [envVar: 'PG_ROOT_PASSWORD', isRequired: false, vaultKey: 'pg_root_password'],
      [envVar: 'PG_PASSWORD_HOMOLOGACAO', isRequired: false, vaultKey: 'db_password_staging'],
      [envVar: 'DB_USER_DUMP', isRequired: false, vaultKey: 'db_user_dump'],
      [envVar: 'DB_PASSWORD_DUMP', isRequired: false, vaultKey: 'db_password_dump']
    ]
  ]]
}

def secrets = [
  [path: 'secret/3s/config', engineVersion: 2, secretValues: [
    [envVar: 'PG_USER', vaultKey: 'pg_user'], 
    [envVar: 'PG_PASSWORD', vaultKey: 'pg_password'],
    [envVar: 'PG_USER_ROOT', vaultKey: 'pg_user_root'],
    [envVar: 'PG_ROOT_PASSWORD', vaultKey: 'pg_root_password'],
    [envVar: 'PG_PASSWORD_HOMOLOGACAO', vaultKey: 'db_password_staging'],
    [envVar: 'DB_USER_DUMP', vaultKey: 'db_user_dump'],
    [envVar: 'DB_PASSWORD_DUMP', vaultKey: 'db_password_dump']]],
]
def configuration = [vaultUrl: 'https://dti-vault.unilab.edu.br',  vaultCredentialId: 'id-3s-role', engineVersion: 2]

pipeline {
  agent {
    kubernetes {
      yamlFile './kubernetes/agent/jenkins-agent-pod-k8s.yaml'
      inheritFrom 'inbound'
      idleMinutes 5
      defaultContainer 'php8'
    }
  }
  options {
    timestamps()
    timeout(time: 2, unit: 'HOURS')
    parallelsAlwaysFailFast()
    rateLimitBuilds(throttle: [count: 3, durationName: 'minute', userBoost: false])
    ansiColor('xterm')
    buildDiscarder(logRotator(numToKeepStr: '20'))
    disableConcurrentBuilds()
  }
  triggers {
    cron('0 0 * * 1') 
  }
  environment {
    APP_NAME = "app-3s"
    APP_VERSION = "1.0.0"
    APP_NAMESPACE = "app-3s"
    DOCKER_TAG = "${env.GIT_BRANCH.split('/')[-1]}"
    DOCKER_IMAGE = "dti-registro.unilab.edu.br/unilab/${APP_NAME}"
    BUILD_NUMBER = "${env.BUILD_NUMBER}"
    DOCKER_BUILDKIT = 1
    TF_IN_AUTOMATION = 1
    THREAD_COUNT = 6
    SEMGREP_TIMEOUT = "300"
    JENKINS_URL = "https://dti-jenkins.unilab.edu.br"
    SONAR_URL = "https://dti-sonar.unilab.edu.br"
    kubeconfigCluster = "c1"
    recipientLeadEmail = "erivandosena@gmail.com"
    recipientTeamEmails = "erivandoramos@unilab.edu.br"
    VAULT_ADDR = "https://dti-vault.unilab.edu.br"
    /* Database 3S */
    PG_USER = "*"
    PG_PASSWORD = "*"
    PG_USER_ROOT = "*"
    PG_ROOT_PASSWORD = "*"
    PG_PASSWORD_HOMOLOGACAO = "*"
    PG_DATABASE = "3s-ocorrencias"
    PG_DATABASE_HOMOLOGACAO = "3s-homologacao"
    PG_HOST = "10.130.0.154"
    PG_PORT = "5432"
    /* Database 3S VM Legado*/
    DB_USER_DUMP = "*"
    DB_PASSWORD_DUMP = "*"
    DB_DATABASE_DUMP = "ocorrencias"
    HOST_DUMP = "200.129.19.134"
    PORT_DUMP = "5432"
    USERS_DUMP = '"cicero_robson" "luansidney" "manoeljr"'
    USERS_DUMP_ROOT = '"ocorrencias_user" "admindti" "3s"'
    PGPASSFILE="/home/jenkins/agent/workspace/.pgpass"
  }
  stages {
    stage('Iniciando CI/CD') {
      steps {
        milestone(ordinal: null, label: "Milestone: Setup")
        script {
          currentBuild.displayName = "$BUILD_DISPLAY_NAME (${GIT_COMMIT.take(8)})"
          workspace = "$env.WORKSPACE"
        }
        // executar alguns comandos shell para configurar outros detalhes.
        sh '''
          # Instala pacotes
          apt-get update && apt-get upgrade -y 
          apt-get install -y locales sudo curl wget postgresql-client unzip rsync procps

          # Setup locale
          DEBIAN_FRONTEND=noninteractive dpkg-reconfigure locales 
          sed -i 's/# pt_BR.UTF-8 UTF-8/pt_BR.UTF-8 UTF-8/' /etc/locale.gen
          locale-gen pt_BR.UTF-8
          echo LANG=pt_BR.UTF-8 | tee /etc/default/locale
          echo LC_CTYPE=pt_BR.UTF-8 | tee -a /etc/default/locale
          echo LC_ALL=pt_BR.UTF-8 | tee -a /etc/default/locale
          echo LANGUAGE=pt_BR:pt:en | tee -a /etc/default/locale

          # Instala kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" 
          curl -LO "https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256"
          echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check
          chmod u+x ./kubectl
          install -o root -g root -m 0755 kubectl /usr/bin/kubectl
          kubectl version --client -ojson

          # Instala Vault
          curl -o vault.zip -k https://releases.hashicorp.com/vault/1.12.1/vault_1.12.1_linux_amd64.zip; yes | unzip vault.zip

          # Instala compose
          curl -sS https://getcomposer.org/installer -o composer-setup.php 
          php composer-setup.php --install-dir=/usr/local/bin --filename=composer 
          chown -R www-data:www-data /usr/local/bin/composer 

          # Obtem o vendor
          composer create-project laravel/laravel --prefer-dist /tmp/proj-laravel
          ls -la /tmp/proj-laravel
          cp -ra source/ /tmp/proj-laravel/
          rsync --progress --recursive -arvPo /tmp/proj-laravel/ source/
          mv source/.env.example source/.env
          ls -la source/
          printenv
        '''
      }
    }

    // stage('SonarQube Analysis') {
    //   steps {
    //     container('maven') {
    //       script {
    //         def branchName = env.BRANCH_NAME
    //         def scannerHome = tool 'SonarScanner'
    //         withSonarQubeEnv('SonarQube') {
    //           sh "${scannerHome}/bin/sonar-scanner -Dsonar.projectKey=app-3s -Dsonar.sources=source/app3s -Dsonar.exclusions=vendor/** -Dsonar.language=php -Dsonar.sourceEncoding=UTF-8"
    //           def props = readProperties  file: '.scannerwork/report-task.txt'
    //           def sonarServerUrl=props['serverUrl']
    //           def ceTaskUrl= props['ceTaskUrl']
    //           def ceTask
    //           timeout(time: 2, unit: 'MINUTES') {
    //               waitUntil {
    //                   def response = httpRequest(url: ceTaskUrl, authentication: 'sonar-admin')
    //                   ceTask = readJSON text: response.content
    //                   echo ceTask.toString()
    //                   return "SUCCESS".equals(ceTask["task"]["status"])
    //               }
    //           }
    //           /* Quality Gate */
    //           def resp = httpRequest(url : sonarServerUrl + "/api/qualitygates/project_status?analysisId=" + ceTask["task"]["analysisId"], authentication: 'sonar-admin')
    //           def qualitygate = readJSON text: resp.content
    //           echo qualitygate.toString()
    //           if ("ERROR".equals(qualitygate["projectStatus"]["status"])) {
    //             error "Pipeline abortada devido a falha em Quality Gate: ${qualitygate.status}"
    //             waitForQualityGate abortPipeline: true
    //           }
    //         }
    //       }
    //     } 
    //   }
    // }
    stage('Testes') {
      steps {
        sh 'cd source/ && php artisan key:generate && php artisan make:test tests/BasicTest && composer dump-autoload'
        sh 'source/vendor/bin/phpunit --no-configuration --no-extensions source/tests/'
      }
    }
    // stage('Build') {
    //   steps {
    //     container('docker') {
    //       milestone(ordinal: null, label: "Milestone: Docker Build")
    //       timeout(time: 60, unit: 'MINUTES') {
    //         sh "docker build -f ./Dockerfile --target production -t '$DOCKER_IMAGE:$DOCKER_TAG' --build-arg 'VERSION=$APP_VERSION COMMIT_SHA=$GIT_COMMIT BUILDKIT_INLINE_CACHE=1' --no-cache ."
    //       }
    //     }
    //   }
    // }
    stage('Obter segredos do Vault') {
      steps {
        script {
          /* secrets harbor */
          env.VAULT_ADDR = "https://dti-vault.unilab.edu.br"
          withCredentials([
            string(credentialsId: 'role-harbor', variable: 'ROLE_ID'),
            string(credentialsId: 'token-admin', variable: 'VAULT_TOKEN')
            ]) {
              env.SECRET_ID = sh(script: './vault write -tls-skip-verify -field=secret_id -f auth/approle/role/harbor-role/secret-id', returnStdout: true).trim()
              env.VAULT_TOKEN = sh(script: './vault write -tls-skip-verify -field=token auth/approle/login role_id=${ROLE_ID} secret_id=${SECRET_ID}', returnStdout: true).trim()
              env.HARBOR_USERNAME = sh(script: './vault kv get -tls-skip-verify -field=usuario secret/harbor/config', returnStdout: true).trim()
              env.HARBOR_PASSWORD = sh(script: './vault kv get -tls-skip-verify -field=senha secret/harbor/config', returnStdout: true).trim()

              // env.PG_USER=sh(script: './vault kv get -tls-skip-verify -field=pg_user secret/3s/config', returnStdout: true).trim()
              // env.PG_PASSWORD=sh(script: './vault kv get -tls-skip-verify -field=pg_password secret/3s/config', returnStdout: true).trim()
              // env.PG_USER_ROOT=sh(script: './vault kv get -tls-skip-verify -field=pg_user_root secret/3s/config', returnStdout: true).trim()
              // env.PG_ROOT_PASSWORD=sh(script: './vault kv get -tls-skip-verify -field=pg_root_password secret/3s/config', returnStdout: true).trim()
              // env.PG_PASSWORD_HOMOLOGACAO=sh(script: './vault kv get -tls-skip-verify -field=db_password_staging secret/3s/config', returnStdout: true).trim()
              // env.DB_USER_DUMP=sh(script: './vault kv get -tls-skip-verify -field=db_user_dump secret/3s/config', returnStdout: true).trim()
              // env.DB_PASSWORD_DUMP=sh(script: './vault kv get -tls-skip-verify -field=db_password_dump secret/3s/config', returnStdout: true).trim()
          }
        }
      }
    }

    // stage('Push Image Container') {
    //   steps {
    //     container('docker') { 
    //       milestone(ordinal: null, label: "Milestone: Docker Push")
    //       timeout(time: 15, unit: 'MINUTES') {
    //         sh """
    //           echo \${HARBOR_PASSWORD} | docker login --username \${HARBOR_USERNAME} --password-stdin https://dti-registro.unilab.edu.br
    //           unset HARBOR_PASSWORD
    //           docker push \${DOCKER_IMAGE}:\${DOCKER_TAG}
    //         """
    //       }
    //     }
    //   }
    // }

    stage('Setup Database') {
      steps {
        script {
          withKubeConfig([credentialsId: 'kubeconfig-c1', serverUrl: 'https://dti-k8s-c1.unilab.edu.br:6443']) {
            sh '''
              if ! kubectl get statefulset postgres -n postgres-3s >/dev/null 2>&1; then
                kubectl apply -f ./kubernetes/statefulSet-postgres-3s.yaml --record
              fi
              echo "Lista de recursos."
              kubectl get all,sa,ing,pvc -n postgres-3s -o wide
            '''
          }
        
          withVault([configuration: configuration, vaultSecrets: secrets]) {
            withEnv([
              "PG_USER=${env.PG_USER}",
              "PG_PASSWORD=${env.PG_PASSWORD}",
              "PG_USER_ROOT=${env.PG_USER_ROOT}",
              "PG_ROOT_PASSWORD=${env.PG_ROOT_PASSWORD}",
              "PG_PASSWORD_HOMOLOGACAO=${env.PG_PASSWORD_HOMOLOGACAO}",
              "DB_USER_DUMP=${env.DB_USER_DUMP}",
              "DB_PASSWORD_DUMP=${env.DB_PASSWORD_DUMP}"
            ]) {
              sh """
                echo '${env.PG_USER}' > ./secret.txt
                echo '${env.PG_PASSWORD}' >> ./secret.txt
                echo '${env.PG_USER_ROOT}' >> ./secret.txt
                echo '${env.PG_ROOT_PASSWORD}' >> ./secret.txt
                echo '${env.PG_PASSWORD_HOMOLOGACAO}' >> ./secret.txt
                echo '${env.DB_USER_DUMP}' >> ./secret.txt
                echo '${env.DB_PASSWORD_DUMP}' >> ./secret.txt
                cat ./secret.txt

                echo '${env.PG_HOST}:${env.PG_PORT}:*:${env.PG_USER_ROOT}:${env.PG_ROOT_PASSWORD}' > /home/jenkins/agent/workspace/.pgpass
                echo '${env.PG_HOST}:${env.PG_PORT}:*:${env.PG_USER}:${env.PG_PASSWORD}' >> /home/jenkins/agent/workspace/.pgpass
                echo '${env.PG_HOST}:${env.PG_PORT}:*:${env.PG_USER}:${env.PG_PASSWORD_HOMOLOGACAO}' >> /home/jenkins/agent/workspace/.pgpass
                echo '${env.HOST_DUMP}:${env.PORT_DUMP}:*:${env.DB_USER_DUMP}:${env.DB_PASSWORD_DUMP}' >> /home/jenkins/agent/workspace/.pgpass
                chmod 0600 /home/jenkins/agent/workspace/.pgpass
                cat /home/jenkins/agent/workspace/.pgpass
              """
            }
            sh """
              printenv

              chmod +x source/docker/database/setup-databases.sh
              ./source/docker/database/setup-databases.sh 
            """
          }
        }
      }
    }

    stage('Deploy em Staging') {
      steps {
        script {
          withVault(configuration: [
            engineVersion: 2, 
            skipSslVerification: true, 
            timeout: 60, 
            vaultCredentialId: 'token-admin-vault-plugin', 
            vaultUrl: 'https://dti-vault.unilab.edu.br'], 
            vaultSecrets: getSecretsConfig()) {
            withEnv([
              "PG_USER=${env.PG_USER}",
              "PG_PASSWORD=${env.PG_PASSWORD}",
              "PG_USER_ROOT=${env.PG_USER_ROOT}",
              "PG_ROOT_PASSWORD=${env.PG_ROOT_PASSWORD}",
              "PG_PASSWORD_HOMOLOGACAO=${env.PG_PASSWORD_HOMOLOGACAO}",
              "DB_USER_DUMP=${env.DB_USER_DUMP}",
              "DB_PASSWORD_DUMP=${env.DB_PASSWORD_DUMP}"
            ]) {
              //sh 'printenv'
              sh 'cat ./secret.txt'
              }

              // sh "chmod +x source/docker/database/dump-database.sh"
              // sh "chmod +x source/docker/database/restore-database.sh"
              // sh "./source/docker/database/dump-database.sh"
              // // sh './source/docker/database/restore-database.sh restore_postgres_homolog'

              sh ''' #!/bin/bash 

              chmod +x source/docker/database/dump-database.sh
              chmod +x source/docker/database/restore-database.sh
              ./source/docker/database/dump-database.sh
              ls -la /tmp
              ./source/docker/database/restore-database.sh restore_postgres_homolog
              ls -la /tmp
              '''
    

            sh """
              ls -la .
              pwd
              printenv
              sed -i 's/postgres.postgres-3s.svc.cluster.local/10.130.0.154/' ./kubernetes/deployment-3s.yaml
              sed -i 's/3s-ocorrencias/3s-homologacao/' ./kubernetes/deployment-3s.yaml
              sed -i 's/:latest/:${env.DOCKER_TAG}/' ./kubernetes/deployment-3s.yaml
              sed -i 's/.pg_password/.pg_password_staging/' ./kubernetes/deployment-3s.yaml
              sed -i 's/auth\\/kubernetes\\/c1/auth\\/kubernetes\\/c3/' ./kubernetes/deployment-3s.yaml
              sed -i 's/harbor-regcred-k8sc1/harbor-regcred-k8sc3/' ./kubernetes/deployment-3s.yaml
              sed -i 's/10.130.0.153/10.130.2.153/' ./kubernetes/deployment-3s.yaml
              sed -i 's/dti-app-test-c1.unilab.edu.br/3shomologacao.unilab.edu.br/' ./kubernetes/deployment-3s.yaml
              cat ./kubernetes/deployment-3s.yaml
            """
          }

          withKubeConfig([credentialsId: 'kubeconfig-c3', serverUrl: 'https://dti-k8s-c3.unilab.edu.br:6443']) {
            //script {
              sh """
                echo 'Verifica deploy ativo e exclui.'
                kubectl get deployment $APP_NAME -n $APP_NAMESPACE >/dev/null 2>&1 && \
                (kubectl get pods -l $APP_NAME -n $APP_NAMESPACE --no-headers | wc -l) > 0 && \
                kubectl delete pods -l app=$APP_NAME -n $APP_NAMESPACE --force --grace-period=0; \
                kubectl delete deployment $APP_NAME -n $APP_NAMESPACE || echo 'DEPLOYMENT INEXISTENTE!'
                
                echo 'Aplica deploy.'
                kubectl apply -f ./kubernetes/deployment-3s.yaml --record

                echo 'Lista de recursos.'
                kubectl get all,sa,ing,pvc -n $APP_NAMESPACE -o wide
              """
              env.APP_URI_STAGING = sh(script: 'kubectl get ingress app-3s -n app-3s -o jsonpath="{.spec.rules[0].host}" | sed "s/^/http:\\/\\//"', returnStdout: true).trim()
              withEnv(["APP_URI=${env.APP_URI}"]) {
                echo 'Endpoint: $APP_URI'
              }
            //}
          }
        }
      }
    }
    // stage('Aprovar Deploy') {
    //   steps {
    //     script {
    //       emailext mimeType: 'text/html',
    //         subject: "APROVAR Deploy [${env.JOB_NAME}] ${currentBuild.fullDisplayName}",
    //         to: "${env.recipientLeadEmail}",
    //         body: "Prezado(a) Leader\n\nExiste um Continuous Deployment aguardando sua aprovação na produção." +
    //           "<a href='${BUILD_URL}input'><strong>Ir para APROVAÇÃO</strong></a>\n\n" +
    //           "Endpoint da homologação: ${env.APP_URI_STAGING}\n\n${env.EMAIL_ASSINATURA}\n\n\n${env.EMAIL_RODAPE}"

    //       timeout(time: 48, unit: 'HOURS') {
    //         input id: 'EnvType', 
    //         message: 'Aprovar Deploy?', 
    //         ok: 'APROVAR', parameters: [
    //           choice(name: 'Cluster', choices: ['Kubernetes C1', 'Kubernetes C2', 'Kubernetes C3'], description: 'Selecione o cluster para implantar')
    //         ], 
    //         submitter: 'erivando,admin', submitterParameter: 'approverId'
    //       }

    //       switch (Cluster) {
    //         case 'Kubernetes C1':
    //           env.kubeconfigCluster = 'c1'
    //           break
    //         case 'Kubernetes C2':
    //           env.kubeconfigCluster = 'c2'
    //           break
    //         case 'Kubernetes C3':
    //           env.kubeconfigCluster = 'c3'
    //           break
    //         default:
    //           error "Opção inválida"
    //       }
    //     }
    //   }
    // }
    // stage('Deploy Produção') {
    //   steps {
    //     script {
    //       withVault(configuration: [
    //       engineVersion: 2, 
    //       skipSslVerification: true, 
    //       timeout: 60, 
    //       vaultCredentialId: 'token-admin-vault-plugin', 
    //       vaultUrl: 'https://dti-vault.unilab.edu.br'], 
    //       vaultSecrets: [[
    //         engineVersion: 2, 
    //         path: 'secret/3s/config', 
    //         secretValues: [
    //           [envVar: 'PG_USER', isRequired: false, vaultKey: 'pg_user'], 
    //           [envVar: 'PG_PASSWORD', isRequired: false, vaultKey: 'pg_password'],
    //           [envVar: 'PG_USER_ROOT', isRequired: false, vaultKey: 'pg_user_root'],
    //           [envVar: 'PG_ROOT_PASSWORD', isRequired: false, vaultKey: 'pg_root_password'],
    //           [envVar: 'PG_PASSWORD_HOMOLOGACAO', isRequired: false, vaultKey: 'db_password_staging'],
    //           [envVar: 'DB_USER_DUMP', isRequired: false, vaultKey: 'db_user_dump'],
    //           [envVar: 'DB_PASSWORD_DUMP', isRequired: false, vaultKey: 'db_password_dump']
    //           ]]]) {
    //             // some block
    //             withEnv([
    //               "PG_USER=$PG_USER",
    //               "PG_PASSWORD=$PG_PASSWORD",
    //               "PG_USER_ROOT=$PG_USER_ROOT",
    //               "PG_ROOT_PASSWORD=$PG_ROOT_PASSWORD",
    //               "PG_PASSWORD_HOMOLOGACAO=$PG_PASSWORD_HOMOLOGACAO",
    //               "DB_USER_DUMP=$DB_USER_DUMP",
    //               "DB_PASSWORD_DUMP=$DB_PASSWORD_DUMP"
    //             ]) {
    //               sh 'printenv'
    //               sh 'cat ./secret.txt'
    //               sh 'cat ~/.pgpass'
    //             }
    //       }

    //       sh "chmod +x source/docker/database/dump-database.sh"
    //       sh "chmod +x source/docker/database/restore-database.sh"
    //       sh "./source/docker/database/dump-database.sh"
    //       sh "./source/docker/database/restore-database.sh $PG_DATABASE"
    
    //       sh "sed -i 's/:latest/:${env.DOCKER_TAG}/' ./kubernetes/deployment-3s.yaml"
    //       sh 'cat ./kubernetes/deployment-3s.yaml'
    //     }

    //     withKubeConfig([credentialsId: 'kubeconfig-${env.kubeconfigCluster}', serverUrl: 'https://dti-k8s-${env.kubeconfigCluster}.unilab.edu.br:6443']) {
    //       /*
    //       Teoricamente --record não é obrigatório, porém, tecnicamente torna-se obrigatório para garantir que as 
    //       alterações deixem um rastro de auditoria rudimentar e cumpram o processo SRE e a cultura DevOps.
    //       Exemplo de uso: kubectl rollout history -n docker deployment.apps/docker
    //       Nota: Quando --record não é sinalizador, na tabela, CHANGE-CAUSE estará apenas <none>
    //       */
    //       script {
    //         sh '''
    //           set -x
    //           echo "Verifica deploy ativo e exclui."
    //           kubectl get deployment $APP_NAME -n $APP_NAMESPACE >/dev/null 2>&1 && \
    //           (kubectl get pods -l $APP_NAME -n $APP_NAMESPACE --no-headers | wc -l) > 0 && \
    //           kubectl delete pods -l app=$APP_NAME -n $APP_NAMESPACE --force --grace-period=0; \
    //           kubectl delete deployment $APP_NAME -n $APP_NAMESPACE || echo 'DEPLOYMENT INEXISTENTE!'
              
    //           echo "Aplica deploy."
    //           kubectl apply -f ./kubernetes/deployment-3s.yaml --record

    //           echo "Lista de recursos."
    //           kubectl get all,sa,ing,pvc -n $APP_NAMESPACE -o wide
    //         '''
    //         env.APP_URI_PROD = sh(script: 'kubectl get ingress app-3s -n app-3s -o jsonpath="{.spec.rules[0].host}" | sed "s/^/http:\\/\\//"', returnStdout: true).trim()
    //       }
    //     }
    //   }
    // }
  }
}
// post{
//   always {
//     echo 'Processo de pipeline finalizado.'
//     slackSend(color: "warning", message: "Pipeline #${env.BUILD_NUMBER} finalizada com ${currentBuild.currentResult} em ${env.JOB_NAME} (<${env.BUILD_URL}|Mais info...>)")
//   }
//   success {
//     echo 'Processo de pipeline BEM-SUCEDIDO.'
//     sh "curl -o build-log.txt ${env.JENKINS_URL}/job/${env.JOB_NAME}/lastBuild/timestamps/?appendLog"
//     archiveArtifacts artifacts: 'build-log.txt', onlyIfSuccessful: true
//     emailext attachLog: true, attachmentsPattern: 'build-log.txt',
//         recipientProviders: ["${recipientTeamEmails}", developers(), requestor()],
//         subject: "Pipeline #${env.BUILD_NUMBER} ${currentBuild.currentResult} Job ${env.JOB_NAME}",
//         body: "Pipeline completada com: ${currentBuild.currentResult}\n\n" +
//               "Detalhes da execução da pipeline: ${env.BUILD_URL}\n" +
//               "Detalhes do teste de qualidade: ${env.SONAR_URL}/dashboard?id=${env.APP_NAME}\n" +
//               "Endpoint de homologação: ${env.APP_URI_STAGING}\n" +
//               "Endpoint de produção: ${env.APP_URI_PROD}\n\n${env.EMAIL_ASSINATURA}\n\n\n${env.EMAIL_RODAPE}"

//     slackSend(color: "good", message: "${slack_msg()}")
//     slackSend(color: "good", message: "Pipeline #${env.BUILD_NUMBER} completada com ${currentBuild.currentResult} em ${env.JOB_NAME} (<${env.BUILD_URL}|Mais info...>)")
//   }
//   failure {
//     echo 'Processo de pipeline executado com falha.'
//     sh "curl -o build-log.txt ${env.JENKINS_URL}/job/${env.JOB_NAME}/lastBuild/timestamps/?appendLog"
//     archiveArtifacts artifacts: 'build-log.txt', onlyIfSuccessful: true
//     emailext attachLog: true, attachmentsPattern: 'build-log.txt',
//         recipientProviders: [developers(), requestor()],
//         subject: "Pipeline #${env.BUILD_NUMBER} ${currentBuild.currentResult} Job ${env.JOB_NAME}",
//         body: "Pipeline completada com: ${currentBuild.currentResult}\n" +
//               "Detalhes da execução da pipeline: ${env.BUILD_URL}\n\n${env.EMAIL_ASSINATURA}\n\n\n${env.EMAIL_RODAPE}"

//     slackSend(color: "danger", message: "Pipeline #${env.BUILD_NUMBER} ${currentBuild.currentResult} em ${env.JOB_NAME} (<${env.BUILD_URL}|Mais info...>)")
//   }
//   unstable {
//     echo 'Processo de pipeline possui estabilidade.'
//   }
//   changed {
//     echo 'SUCESSO no processo de pipeline anteriormente falhado.'
//   }
// }

// def slack_msg() {
//   def JOB_NAME = env.JOB_NAME
//   def BUILD_ID = env.BUILD_ID
//   def JENKINS_MSG = "Pipeline [${env.JOB_NAME}] finalizada com SUCESSO!\n" +
//   "Logs path: ${env.JENKINS_URL}/job/${JOB_NAME}/${BUILD_ID}/consoleText\n" +
//   "Quality Gate: ${env.SONAR_URL}/dashboard?id=${env.APP_NAME}"
//   return JENKINS_MSG
// }
