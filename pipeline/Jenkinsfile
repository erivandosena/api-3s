#!/usr/bin/env groovy

pipeline {
  agent {
    kubernetes {
      yamlFile './pipeline/jenkins-agent-pod-k8s.yaml'
      inheritFrom 'inbound'
      idleMinutes 5
      defaultContainer 'php8'
    }
  }
  options {
    timestamps()
    timeout(time: 2, unit: 'HOURS')
    parallelsAlwaysFailFast()
    rateLimitBuilds(throttle: [count: 3, durationName: 'minute', userBoost: false])
    buildDiscarder(logRotator(numToKeepStr: '100'))
    ansiColor('xterm')
  }
  triggers { // crontab.guru
    // Pipeline com gatilho semanal ativo e via GitLab Pushs.
    cron('0 0 * * 1') 
  }
  
  environment {
    APP_NAME = "app-3s"
    APP_VERSION = "1.0.0"
    APP_NAMESPACE = "app-3s"
    DOCKER_TAG = "${env.GIT_BRANCH.split('/')[-1]}"
    DOCKER_IMAGE = "dti-registro.unilab.edu.br/unilab/${APP_NAME}"
    BUILD_NUMBER = "${env.BUILD_NUMBER}"
    DOCKER_BUILDKIT = 1
    TF_IN_AUTOMATION = 1
    THREAD_COUNT = 6
    SEMGREP_TIMEOUT = "300"
    SONAR_HOST_URL = "https://dti-sonar.unilab.edu.br"
    recipientEmails = "erivandoramos@unilab.edu.br"
  }
  stages {
    stage('Iniciando CI/CD') {
      steps {
        milestone(ordinal: null, label: "Milestone: Setup")
        script {
          currentBuild.displayName = "$BUILD_DISPLAY_NAME (${GIT_COMMIT.take(8)})"
          workspace = "$env.WORKSPACE"
        }
        // executar alguns comandos shell para configurar outros detalhes

        // Instalar kubectl - Oficial docs https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/
        sh 'curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"'
        sh 'curl -LO "https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256"'
        sh 'echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check'
        sh "chmod u+x ./kubectl"
        sh "install -o root -g root -m 0755 kubectl /usr/bin/kubectl"
        sh "kubectl version --client -ojson" // apenas para testar a conexão client

        sh 'printenv'
        sh 'ls -la .'
      }
    }
    stage('Build') {
      steps {
        script {
          sh '''
            apt-get update && apt-get install -y --no-install-recommends \
              curl \
              git \
              unzip \
              rsync \
              && rm -rf /var/lib/apt/lists/*
          '''
          sh '''
            curl -sS https://getcomposer.org/installer -o composer-setup.php \
            && php composer-setup.php --install-dir=/usr/local/bin --filename=composer \
            && chown -R www-data:www-data /usr/local/bin/composer 
          '''
          }
          //sh 'cd source && su www-data -s /bin/bash -c "composer install --ignore-platform-reqs --no-interaction --no-progress --no-scripts --optimize-autoloader"'
          sh 'composer create-project laravel/laravel --prefer-dist /tmp/proj-laravel'
          sh 'ls -la /tmp/proj-laravel'
          sh 'cp -ra source/ /tmp/proj-laravel/'
          sh 'rsync --progress --recursive -arvPo /tmp/proj-laravel/ source/'
          sh 'mv source/.env.example source/.env'
          sh 'ls -la source/'
      }
    }
    stage('Testes') {
      steps {
          sh 'cd source/ && php artisan make:test tests/BasicTest && composer dump-autoload'
          sh 'source/vendor/bin/phpunit tests/'
      }
    }
    stage('Build Image Container') {
      steps {
        container('docker') {  
          milestone(ordinal: null, label: "Milestone: Docker Build")
          timeout(time: 60, unit: 'MINUTES') {
            sh "docker build -f ./Dockerfile --target production -t '$DOCKER_IMAGE:$DOCKER_TAG' --build-arg 'VERSION=$APP_VERSION COMMIT_SHA=$GIT_COMMIT BUILDKIT_INLINE_CACHE=1' --no-cache ."
          }
        }
      }
    }
    stage('Push Image Container') {
      steps {
        container('docker') { 
          withCredentials([usernamePassword(credentialsId: 'harbor-registry', passwordVariable: 'HubImagePassword', usernameVariable: 'HubImageUser')]) {
            sh "docker login https://dti-registro.unilab.edu.br -u ${HubImageUser} -p ${HubImagePassword}"
            milestone(ordinal: null, label: "Milestone: Docker Push")
            timeout(time: 15, unit: 'MINUTES') {
              sh "docker push '$DOCKER_IMAGE:$DOCKER_TAG'"
            }
          }
        }
      }
    }
    stage('Deploy no Kubernetes') {
      steps {
        //sh "sed -i 's/<APP_NAMESPACE>/${env.APP_NAMESPACE}/' ./kubernetes/deployment-3s.yaml"
        
        //sh "sed -i 's/<APP_NAME>/${env.APP_NAME}/' ./kubernetes/deployment-3s.yaml"
        
        //sh "sed -i 's/<CONTAINER_NAME>/${env.APP_NAME}/' ./kubernetes/deployment-3s.yaml"
  
        sh "sed -i 's/:main/:${env.DOCKER_TAG}/' ./kubernetes/deployment-3s.yaml"

        sh 'cat ./kubernetes/deployment-3s.yaml'

        withKubeConfig([credentialsId: 'kubeconfig-c1', serverUrl: 'http://dti-k8s-c1.unilab.edu.br:6443']) {

          /*
          Teoricamente --record não é obrigatório, porém, tecnicamente torna-se obrigatório para garantir que as 
          alterações deixem um rastro de auditoria rudimentar e cumpram o processo SRE e a cultura DevOps.
          Exemplo de uso: kubectl rollout history -n docker deployment.apps/docker
          Nota: Quando --record não é sinalizador, na tabela, CHANGE-CAUSE estará apenas <none>
          */

          script {
            sh '''
              set -x
              echo "Verifica deploy ativo e exclui."
              kubectl get deployment $APP_NAME -n $APP_NAMESPACE >/dev/null 2>&1 && \
              (kubectl get pods -l $APP_NAME -n $APP_NAMESPACE --no-headers | wc -l) > 0 && \
              kubectl delete pods -l app=$APP_NAME -n $APP_NAMESPACE --force --grace-period=0; \
              kubectl delete deployment $APP_NAME -n $APP_NAMESPACE || echo 'DEPLOYMENT INEXISTENTE!'
              
              echo "Aplica deploy."
              kubectl apply -f ./kubernetes/deployment-3s.yaml --record

              echo "Verifica deploy ativo e exclui."
              kubectl get deployment postgres -n postgres-3s >/dev/null 2>&1 && \
              (kubectl get pods -l postgres -n postgres-3s --no-headers | wc -l) > 0 && \
              kubectl delete pods -l app=postgres -n postgres-3s --force --grace-period=0; \
              kubectl delete deployment postgres -n postgres-3s || echo 'DEPLOYMENT INEXISTENTE!'

              echo "Aplica deploy."
              kubectl apply -f ./kubernetes/statefulSet-postgres-3s.yaml --record

              echo "Lista de recursos."
              kubectl get all,ing -n $APP_NAMESPACE -o wide
              kubectl get all,ing -n postgres-3s -o wide
            '''
            env.APP_URI = sh "kubectl get ingress $APP_NAME -n $APP_NAME -o jsonpath='{.spec.rules[0].host}' | sed 's/^/http:\\/\\/\\/'"
            withEnv(["APP_URI=${env.APP_URI}"]) {
                sh 'echo Endpoint: $APP_URI'
            }
          }
        }
      }
    }
  }
  post{
    always {
      echo 'Processo de pipeline finalizado.'
    }
    success {
      echo 'Processo de pipeline BEM-SUCEDIDO.'
      mail to: "${recipientEmails}",
      subject: "Pipeline #${env.BUILD_NUMBER} - ${env.JOB_NAME}",
      body: "Pipeline completada com: ${currentBuild.currentResult}\n" +
            "Mais detalhes em: ${env.BUILD_URL}\n" +
            "Endpoint do serviço: ${env.APP_URI}\n\n${env.EMAIL_ASSINATURA}\n\n\n${env.EMAIL_RODAPE}"
    }
    failure {
      echo 'Processo de pipeline executado com falha.'
    }
    unstable {
      echo 'Processo de pipeline possui estabilidade.'
    }
    changed {
      echo 'SUCESSO no processo de pipeline anteriormente falhado.'
    }
  }
}
