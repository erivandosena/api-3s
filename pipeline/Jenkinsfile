#!/usr/bin/env groovy

def getSecretsConfig(){
  return [[
    engineVersion: 2, 
    path: 'secret/3s/config', 
    secretValues: [
      [envVar: 'PG_USER', isRequired: false, vaultKey: 'pg_user'], 
      [envVar: 'PG_PASSWORD', isRequired: false, vaultKey: 'pg_password'],
      [envVar: 'PG_USER_ROOT', isRequired: false, vaultKey: 'pg_user_root'],
      [envVar: 'PG_ROOT_PASSWORD', isRequired: false, vaultKey: 'pg_root_password'],
      [envVar: 'PG_PASSWORD_HOMOLOGACAO', isRequired: false, vaultKey: 'db_password_staging'],
      [envVar: 'DB_USER_DUMP', isRequired: false, vaultKey: 'db_user_dump'],
      [envVar: 'DB_PASSWORD_DUMP', isRequired: false, vaultKey: 'db_password_dump']
    ]
  ]]
}

pipeline {
  agent {
    kubernetes {
      yamlFile './kubernetes/agent/jenkins-agent-pod-k8s.yaml'
      inheritFrom 'inbound'
      idleMinutes 5
      defaultContainer 'php8'
    }
  }
  options {
    timestamps()
    timeout(time: 2, unit: 'HOURS')
    parallelsAlwaysFailFast()
    rateLimitBuilds(throttle: [count: 3, durationName: 'minute', userBoost: false])
    ansiColor('xterm')
    buildDiscarder(logRotator(numToKeepStr: '20'))
    disableConcurrentBuilds()
  }
  triggers { // crontab.guru
    // Pipeline com gatilho semanal ativo e via GitLab Pushs.
    cron('0 0 * * 1') 
  }
  environment {
    APP_NAME = "app-3s"
    APP_VERSION = "1.0.0"
    APP_NAMESPACE = "app-3s"
    DOCKER_TAG = "${env.GIT_BRANCH.split('/')[-1]}"
    DOCKER_IMAGE = "dti-registro.unilab.edu.br/unilab/${APP_NAME}"
    BUILD_NUMBER = "${env.BUILD_NUMBER}"
    DOCKER_BUILDKIT = 1
    TF_IN_AUTOMATION = 1
    THREAD_COUNT = 6
    SEMGREP_TIMEOUT = "300"
    JENKINS_URL = "https://dti-jenkins.unilab.edu.br"
    SONAR_URL = "https://dti-sonar.unilab.edu.br"
    kubeconfigCluster = "c1"
    recipientLeadEmail = "erivandosena@gmail.com"
    recipientTeamEmails = "erivandoramos@unilab.edu.br"
    /* Database 3S */
    PG_USER = "*"
    PG_PASSWORD = "*"
    PG_USER_ROOT = "*"
    PG_ROOT_PASSWORD = "*"
    PG_PASSWORD_HOMOLOGACAO = "*"
    PG_DATABASE = "3s-ocorrencias"
    PG_DATABASE_HOMOLOGACAO = "3s-homologacao"
    PG_HOST = "10.130.0.154"
    PG_PORT = "5432"
    /* Database 3S VM Legado*/
    DB_USER_DUMP = "*"
    DB_PASSWORD_DUMP = "*"
    HOST_DUMP = "200.129.19.134"
    PORT_DUMP = "5432"
    USERS_DUMP = '"3s" "admindti" "cicero_robson" "luansidney" "manoeljr"'
    USERS_DUMP_ROOT = '"3s" "ocorrencias_user"'
    USERS_DUMP_ALL = '"3s" "ocorrencias_user" "admindti" "cicero_robson" "luansidney" "manoeljr"'

    LANG="pt_BR.UTF-8"
    LC_CTYPE="pt_BR.UTF-8"
    LC_ALL="pt_BR.UTF-8"
    LANGUAGE="pt_BR:pt:en"

  }
  stages {
    stage('Iniciando CI/CD') {
      steps {
        milestone(ordinal: null, label: "Milestone: Setup")
        script {
          currentBuild.displayName = "$BUILD_DISPLAY_NAME (${GIT_COMMIT.take(8)})"
          workspace = "$env.WORKSPACE"
        }
        // executar alguns comandos shell para configurar outros detalhes.
        sh '''
          # Instala pacotes
          apt-get update && apt-get install -y --no-install-recommends \
            curl \
            wget \
            unzip \
            rsync \
            postgresql-client \
            locales \
            sudo \
            && rm -rf /var/lib/apt/lists/*

          # Reconfigurar as localidades
          DEBIAN_FRONTEND=noninteractive dpkg-reconfigure locales 
          echo "pt_BR.UTF-8 UTF-8" | tee -a /etc/locale.gen
          locale-gen pt_BR.UTF-8
          echo LANG=pt_BR.UTF-8 | tee /etc/default/locale
          echo LC_CTYPE=pt_BR.UTF-8 | tee -a /etc/default/locale
          echo LC_ALL=pt_BR.UTF-8 | tee -a /etc/default/locale
          echo LANGUAGE=pt_BR:pt:en | tee -a /etc/default/locale
          export LANG=pt_BR.UTF-8
          export LC_CTYPE=pt_BR.UTF-8
          export LC_ALL=pt_BR.UTF-8
          export LANGUAGE=pt_BR:pt:en

          # Instala kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" 
          curl -LO "https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256"
          echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check
          chmod u+x ./kubectl
          install -o root -g root -m 0755 kubectl /usr/bin/kubectl
          kubectl version --client -ojson

          # Instala Vault
          curl -o vault.zip -k https://releases.hashicorp.com/vault/1.12.1/vault_1.12.1_linux_amd64.zip; yes | unzip vault.zip

          # Instala compose
          curl -sS https://getcomposer.org/installer -o composer-setup.php 
          php composer-setup.php --install-dir=/usr/local/bin --filename=composer 
          chown -R www-data:www-data /usr/local/bin/composer 
        '''
        sh '''
          # Obtem o vendor
          composer create-project laravel/laravel --prefer-dist /tmp/proj-laravel
          ls -la /tmp/proj-laravel
          cp -ra source/ /tmp/proj-laravel/
          rsync --progress --recursive -arvPo /tmp/proj-laravel/ source/
          mv source/.env.example source/.env
          ls -la source/
          printenv
        '''
      }
    }
    stage('SonarQube Analysis') {
      steps {
        container('maven') {
          script {
            def branchName = env.BRANCH_NAME
            def scannerHome = tool 'SonarScanner'
            withSonarQubeEnv('SonarQube') {
              sh "${scannerHome}/bin/sonar-scanner -Dsonar.projectKey=app-3s -Dsonar.sources=source/app3s -Dsonar.exclusions=vendor/** -Dsonar.language=php -Dsonar.sourceEncoding=UTF-8"
              def props = readProperties  file: '.scannerwork/report-task.txt'
              def sonarServerUrl=props['serverUrl']
              def ceTaskUrl= props['ceTaskUrl']
              def ceTask
              timeout(time: 2, unit: 'MINUTES') {
                  waitUntil {
                      def response = httpRequest(url: ceTaskUrl, authentication: 'sonar-admin')
                      ceTask = readJSON text: response.content
                      echo ceTask.toString()
                      return "SUCCESS".equals(ceTask["task"]["status"])
                  }
              }
              /* Quality Gate */
              def resp = httpRequest(url : sonarServerUrl + "/api/qualitygates/project_status?analysisId=" + ceTask["task"]["analysisId"], authentication: 'sonar-admin')
              def qualitygate = readJSON text: resp.content
              echo qualitygate.toString()
              if ("ERROR".equals(qualitygate["projectStatus"]["status"])) {
                error "Pipeline abortada devido a falha em Quality Gate: ${qualitygate.status}"
                waitForQualityGate abortPipeline: true
              } 
            }
          }
        }
      }
    }
    stage('Testes') {
      steps {
        sh 'cd source/ && php artisan key:generate && php artisan make:test tests/BasicTest && composer dump-autoload'
        sh 'source/vendor/bin/phpunit --no-configuration --no-extensions source/tests/'
      }
    }
    stage('Build') {
      steps {
        container('docker') {
          milestone(ordinal: null, label: "Milestone: Docker Build")
          timeout(time: 60, unit: 'MINUTES') {
            sh "docker build -f ./Dockerfile --target production -t '$DOCKER_IMAGE:$DOCKER_TAG' --build-arg 'VERSION=$APP_VERSION COMMIT_SHA=$GIT_COMMIT BUILDKIT_INLINE_CACHE=1' --no-cache ."
          }
        }
      }
    }
    stage('Obter segredos do Vault') {
      steps {
        script {
          env.VAULT_ADDR = "https://dti-vault.unilab.edu.br"
          /* secrets harbor */
          withCredentials([
            string(credentialsId: 'role-harbor', variable: 'ROLE_ID'),
            string(credentialsId: 'token-admin', variable: 'VAULT_TOKEN')
          ]) {
              env.SECRET_ID = sh(script: './vault write -tls-skip-verify -field=secret_id -f auth/approle/role/harbor-role/secret-id', returnStdout: true).trim()
              env.VAULT_TOKEN = sh(script: './vault write -tls-skip-verify -field=token auth/approle/login role_id=${ROLE_ID} secret_id=${SECRET_ID}', returnStdout: true).trim()
              env.HARBOR_USERNAME = sh(script: './vault kv get -tls-skip-verify -field=usuario secret/harbor/config', returnStdout: true).trim()
              env.HARBOR_PASSWORD = sh(script: './vault kv get -tls-skip-verify -field=senha secret/harbor/config', returnStdout: true).trim()

              env.PG_USER=sh(script: './vault kv get -tls-skip-verify -field=pg_user secret/3s/config', returnStdout: true).trim()
              env.PG_PASSWORD=sh(script: './vault kv get -tls-skip-verify -field=pg_password secret/3s/config', returnStdout: true).trim()
              env.PG_USER_ROOT=sh(script: './vault kv get -tls-skip-verify -field=pg_user_root secret/3s/config', returnStdout: true).trim()
              env.PG_ROOT_PASSWORD=sh(script: './vault kv get -tls-skip-verify -field=pg_root_password secret/3s/config', returnStdout: true).trim()
              env.PG_PASSWORD_HOMOLOGACAO=sh(script: './vault kv get -tls-skip-verify -field=db_password_staging secret/3s/config', returnStdout: true).trim()
              env.DB_USER_DUMP=sh(script: './vault kv get -tls-skip-verify -field=db_user_dump secret/3s/config', returnStdout: true).trim()
              env.DB_PASSWORD_DUMP=sh(script: './vault kv get -tls-skip-verify -field=db_password_dump secret/3s/config', returnStdout: true).trim()
          }
        }
      }
    }

    stage('Push Image Container') {
      steps {
        container('docker') { 
          milestone(ordinal: null, label: "Milestone: Docker Push")
          timeout(time: 15, unit: 'MINUTES') {
            sh """
              echo \${HARBOR_PASSWORD} | docker login --username \${HARBOR_USERNAME} --password-stdin https://dti-registro.unilab.edu.br
              unset HARBOR_PASSWORD
              docker push \${DOCKER_IMAGE}:\${DOCKER_TAG}
            """
          }
        }
      }
    }

    stage('Setup Database') {

      steps {
        withKubeConfig([credentialsId: 'kubeconfig-c1', serverUrl: 'https://dti-k8s-c1.unilab.edu.br:6443']) {
          sh '''
            if ! kubectl get statefulset postgres -n postgres-3s >/dev/null 2>&1; then
              kubectl apply -f ./kubernetes/statefulSet-postgres-3s.yaml --record
            fi
            echo "Lista de recursos."
            kubectl get all,sa,ing,pvc -n postgres-3s -o wide
          '''
        }
        container('php8') {
        withVault(configuration: [
          engineVersion: 2, 
          skipSslVerification: true, 
          timeout: 60, 
          vaultCredentialId: 'token-admin-vault-plugin', 
          vaultUrl: 'https://dti-vault.unilab.edu.br'], 
          vaultSecrets: getSecretsConfig()) {
          script {
            withEnv([
              "PG_USER=${env.PG_USER}",
              "PG_PASSWORD=${env.PG_PASSWORD}",
              "PG_USER_ROOT=${env.PG_USER_ROOT}",
              "PG_ROOT_PASSWORD=${env.PG_ROOT_PASSWORD}",
              "PG_PASSWORD_HOMOLOGACAO=${env.PG_PASSWORD_HOMOLOGACAO}",
              "DB_USER_DUMP=${env.DB_USER_DUMP}",
              "DB_PASSWORD_DUMP=${env.DB_PASSWORD_DUMP}",
              "PG_DATABASE=${env.PG_DATABASE}",
              "PG_DATABASE_HOMOLOGACAO=${env.PG_DATABASE_HOMOLOGACAO}",
              "PG_HOST=${env.PG_HOST}",
              "PG_PORT=${env.PG_PORT}",
              "HOST_DUMP=${env.HOST_DUMP}",
              "PORT_DUMP=${env.PORT_DUMP}",
              "USERS_DUMP=${env.USERS_DUMP}",
              "USERS_DUMP_ROOT =${env.USERS_DUMP_ROOT}",
              "USERS_DUMP_ALL=${env.USERS_DUMP_ALL}"
            ]) {

              sh 'echo $PG_USER > ./secret.txt'
              sh 'echo $PG_PASSWORD >> ./secret.txt'
              sh 'echo $PG_USER_ROOT >> ./secret.txt'
              sh 'echo $PG_ROOT_PASSWORD >> ./secret.txt'
              sh 'echo $PG_PASSWORD_HOMOLOGACAO >> ./secret.txt'
              sh 'echo $DB_USER_DUMP >> ./secret.txt'
              sh 'echo $DB_PASSWORD_DUMP >> ./secret.txt'

              sh 'cat ./secret.txt'

              sh """ 
                #!/bin/bash
                sed -i "s/# pt_BR.UTF-8 UTF-8/pt_BR.UTF-8 UTF-8/" /etc/locale.gen
                chmod +x source/docker/database/setup-databases.sh
                ./source/docker/database/setup-databases.sh 
                cat source/docker/database/setup-databases.sh
              """
              }
            }
          }
          }
        }
      }
    }

    stage('Deploy em Staging') {
      steps {

          withVault(configuration: [
            engineVersion: 2, 
            skipSslVerification: true, 
            timeout: 60, 
            vaultCredentialId: 'token-admin-vault-plugin', 
            vaultUrl: 'https://dti-vault.unilab.edu.br'], 
            vaultSecrets: getSecretsConfig()) {
            script {
              withEnv([
                "PG_USER=$PG_USER",
                "PG_PASSWORD=$PG_PASSWORD",
                "PG_USER_ROOT=$PG_USER_ROOT",
                "PG_ROOT_PASSWORD=$PG_ROOT_PASSWORD",
                "PG_PASSWORD_HOMOLOGACAO=$PG_PASSWORD_HOMOLOGACAO",
                "DB_USER_DUMP=$DB_USER_DUMP",
                "DB_PASSWORD_DUMP=$DB_PASSWORD_DUMP",
                "PG_DATABASE=$PG_DATABASE",
                "PG_DATABASE_HOMOLOGACAO=$PG_DATABASE_HOMOLOGACAO",
                "PG_HOST=$PG_HOST",
                "PG_PORT=$PG_PORT",
                "HOST_DUMP=$HOST_DUMP",
                "PORT_DUMP=$PORT_DUMP",
                "USERS_DUMP=$USERS_DUMP",
                "USERS_DUMP_ROOT =$USERS_DUMP_ROOT",
                "USERS_DUMP_ALL=$USERS_DUMP_ALL"
                ]) {

                echo "PG_USER: ${env.PG_USER}"
                echo "PG_PASSWORD: ${env.PG_PASSWORD}"
                echo "PG_USER_ROOT: ${env.PG_USER_ROOT}"
                echo "PG_ROOT_PASSWORD: ${env.PG_ROOT_PASSWORD}"
                echo "PG_PASSWORD_HOMOLOGACAO: ${env.PG_PASSWORD_HOMOLOGACAO}"
                echo "DB_USER_DUMP: ${env.DB_USER_DUMP}"
                echo "DB_PASSWORD_DUMP: ${env.DB_PASSWORD_DUMP}"

                sh 'echo PG_USER = $PG_USER'
                sh 'echo PG_PASSWORD = $PG_PASSWORD'
                sh 'echo PG_USER_ROOT = $PG_USER_ROOT'
                sh 'echo PG_ROOT_PASSWORD = $PG_ROOT_PASSWORD'
                sh 'echo PG_PASSWORD_HOMOLOGACAO = $PG_PASSWORD_HOMOLOGACAO'
                sh 'echo DB_USER_DUMP = $DB_USER_DUMP'
                sh 'echo DB_PASSWORD_DUMP = $DB_PASSWORD_DUMP'
              }
            

              sh 'echo $PG_USER > ./secret.txt'
              sh 'echo $PG_PASSWORD >> ./secret.txt'
              sh 'echo $PG_USER_ROOT >> ./secret.txt'
              sh 'echo $PG_ROOT_PASSWORD >> ./secret.txt'
              sh 'echo $PG_PASSWORD_HOMOLOGACAO >> ./secret.txt'
              sh 'echo $DB_USER_DUMP >> ./secret.txt'
              sh 'echo $DB_PASSWORD_DUMP >> ./secret.txt'

              sh 'cat ./secret.txt'

              sh 'printenv'
              container('postgres') {
                sh "chmod +x source/docker/database/dump-database.sh"
                sh "chmod +x source/docker/database/restore-database.sh"
                sh "./source/docker/database/dump-database.sh"
                sh "./source/docker/database/restore-database.sh $PG_PASSWORD_HOMOLOGACAO $PG_DATABASE_HOMOLOGACAO"
              }
            }

          }

        // container('postgres') {
        //   script {
        //     sh '''
        //       chmod +x source/docker/database/dump-database.sh
        //       chmod +x source/docker/database/restore-database.sh
        //       ./source/docker/database/dump-database.sh
        //       ./source/docker/database/restore-database.sh $PG_PASSWORD_HOMOLOGACAO $PG_DATABASE_HOMOLOGACAO
        //     '''
        //   }
        // }

        sh '''
          sed -i 's/postgres.postgres-3s.svc.cluster.local/10.130.0.154/' ./kubernetes/deployment-3s.yaml
          sed -i 's/3s-ocorrencias/3s-homologacao/' ./kubernetes/deployment-3s.yaml"
          sed -i 's/:latest/:${env.DOCKER_TAG}/' ./kubernetes/deployment-3s.yaml"
          sed -i 's/.Data.data.pg_password/.Data.data.pg_password_staging/' ./kubernetes/deployment-3s.yaml
          sed -i 's/10.130.0.153/10.130.2.153/' ./kubernetes/deployment-3s.yaml"
          sed -i 's/dti-app-test-c1.unilab.edu.br/3shomologacao.unilab.edu.br/' ./kubernetes/deployment-3s.yaml
          cat ./kubernetes/deployment-3s.yaml
        '''

        withKubeConfig([credentialsId: 'kubeconfig-c3', serverUrl: 'https://dti-k8s-c3.unilab.edu.br:6443']) {
          script {
            sh '''
              set -x
              echo "Verifica deploy ativo e exclui."
              kubectl get deployment $APP_NAME -n $APP_NAMESPACE >/dev/null 2>&1 && \
              (kubectl get pods -l $APP_NAME -n $APP_NAMESPACE --no-headers | wc -l) > 0 && \
              kubectl delete pods -l app=$APP_NAME -n $APP_NAMESPACE --force --grace-period=0; \
              kubectl delete deployment $APP_NAME -n $APP_NAMESPACE || echo 'DEPLOYMENT INEXISTENTE!'
              
              echo "Aplica deploy."
              kubectl apply -f ./kubernetes/deployment-3s.yaml --record

              echo "Lista de recursos."
              kubectl get all,sa,ing,pvc -n $APP_NAMESPACE -o wide
            '''
            env.APP_URI_STAGING = sh(script: 'kubectl get ingress app-3s -n app-3s -o jsonpath="{.spec.rules[0].host}" | sed "s/^/http:\\/\\//"', returnStdout: true).trim()
          }
        }
      }
    }

    stage('Aprovar Deploy') {
      steps {
        script {
          emailext mimeType: 'text/html',
            subject: "APROVAR Deploy [${env.JOB_NAME}] ${currentBuild.fullDisplayName}",
            to: "${env.recipientLeadEmail}",
            body: "Prezado(a) Leader\n\nExiste um Continuous Deployment aguardando sua aprovação na produção." +
              "<a href='${BUILD_URL}input'><strong>Ir para APROVAÇÃO</strong></a>\n\n" +
              "Endpoint da homologação: ${env.APP_URI_STAGING}\n\n${env.EMAIL_ASSINATURA}\n\n\n${env.EMAIL_RODAPE}"

          timeout(time: 48, unit: 'HOURS') {
            input id: 'EnvType', 
            message: 'Aprovar Deploy?', 
            ok: 'APROVAR', parameters: [
              choice(name: 'Cluster', choices: ['Kubernetes C1', 'Kubernetes C2', 'Kubernetes C3'], description: 'Selecione o cluster para implantar')
            ], 
            submitter: 'erivando,admin', submitterParameter: 'approverId'
          }

          switch (Cluster) {
            case 'Kubernetes C1':
              env.kubeconfigCluster = 'c1'
              break
            case 'Kubernetes C2':
              env.kubeconfigCluster = 'c2'
              break
            case 'Kubernetes C3':
              env.kubeconfigCluster = 'c3'
              break
            default:
              error "Opção inválida"
          }
          
        }

      }
    }
    stage('Deploy Produção') {
      steps {
        container('postgres') {
          script {
            // sh '''
            //   chmod +x source/docker/database/dump-database.sh
            //   chmod +x source/docker/database/restore-database.sh
            //   ./source/docker/database/dump-database.sh
            //   ./source/docker/database/restore-database.sh $PG_PASSWORD $PG_DATABASE
            // '''

            sh 'cat ./secret.txt'

            sh 'printenv'

            sh 'chmod +x source/docker/database/dump-database.sh'
            sh 'chmod +x source/docker/database/restore-database.sh'
            sh './source/docker/database/dump-database.sh'
            sh './source/docker/database/restore-database.sh $PG_PASSWORD $PG_DATABASE'

          }
        }
        
        sh "sed -i 's/:latest/:${env.DOCKER_TAG}/' ./kubernetes/deployment-3s.yaml"
        sh 'cat ./kubernetes/deployment-3s.yaml'
        withKubeConfig([credentialsId: 'kubeconfig-${env.kubeconfigCluster}', serverUrl: 'https://dti-k8s-${env.kubeconfigCluster}.unilab.edu.br:6443']) {
          /*
          Teoricamente --record não é obrigatório, porém, tecnicamente torna-se obrigatório para garantir que as 
          alterações deixem um rastro de auditoria rudimentar e cumpram o processo SRE e a cultura DevOps.
          Exemplo de uso: kubectl rollout history -n docker deployment.apps/docker
          Nota: Quando --record não é sinalizador, na tabela, CHANGE-CAUSE estará apenas <none>
          */
          script {
            sh '''
              set -x
              echo "Verifica deploy ativo e exclui."
              kubectl get deployment $APP_NAME -n $APP_NAMESPACE >/dev/null 2>&1 && \
              (kubectl get pods -l $APP_NAME -n $APP_NAMESPACE --no-headers | wc -l) > 0 && \
              kubectl delete pods -l app=$APP_NAME -n $APP_NAMESPACE --force --grace-period=0; \
              kubectl delete deployment $APP_NAME -n $APP_NAMESPACE || echo 'DEPLOYMENT INEXISTENTE!'
              
              echo "Aplica deploy."
              kubectl apply -f ./kubernetes/deployment-3s.yaml --record

              echo "Lista de recursos."
              kubectl get all,sa,ing,pvc -n $APP_NAMESPACE -o wide
            '''
            env.APP_URI_PROD = sh(script: 'kubectl get ingress app-3s -n app-3s -o jsonpath="{.spec.rules[0].host}" | sed "s/^/http:\\/\\//"', returnStdout: true).trim()
          }
        }
      }
    }
  }
  post{
    always {
      echo 'Processo de pipeline finalizado.'
      slackSend(color: "warning", message: "Pipeline #${env.BUILD_NUMBER} finalizada com ${currentBuild.currentResult} em ${env.JOB_NAME} (<${env.BUILD_URL}|Mais info...>)")
    }
    success {
      echo 'Processo de pipeline BEM-SUCEDIDO.'
      sh "curl -o build-log.txt ${env.JENKINS_URL}/job/${env.JOB_NAME}/lastBuild/timestamps/?appendLog"
      archiveArtifacts artifacts: 'build-log.txt', onlyIfSuccessful: true
      emailext attachLog: true, attachmentsPattern: 'build-log.txt',
          recipientProviders: ["${recipientTeamEmails}", developers(), requestor()],
          subject: "Pipeline #${env.BUILD_NUMBER} ${currentBuild.currentResult} Job ${env.JOB_NAME}",
          body: "Pipeline completada com: ${currentBuild.currentResult}\n\n" +
                "Detalhes da execução da pipeline: ${env.BUILD_URL}\n" +
                "Detalhes do teste de qualidade: ${env.SONAR_URL}/dashboard?id=${env.APP_NAME}\n" +
                "Endpoint de homologação: ${env.APP_URI_STAGING}\n" +
                "Endpoint de produção: ${env.APP_URI_PROD}\n\n${env.EMAIL_ASSINATURA}\n\n\n${env.EMAIL_RODAPE}"

      slackSend(color: "good", message: "${slack_msg()}")
      slackSend(color: "good", message: "Pipeline #${env.BUILD_NUMBER} completada com ${currentBuild.currentResult} em ${env.JOB_NAME} (<${env.BUILD_URL}|Mais info...>)")
    }
    failure {
      echo 'Processo de pipeline executado com falha.'
      sh "curl -o build-log.txt ${env.JENKINS_URL}/job/${env.JOB_NAME}/lastBuild/timestamps/?appendLog"
      archiveArtifacts artifacts: 'build-log.txt', onlyIfSuccessful: true
      emailext attachLog: true, attachmentsPattern: 'build-log.txt',
          recipientProviders: [developers(), requestor()],
          subject: "Pipeline #${env.BUILD_NUMBER} ${currentBuild.currentResult} Job ${env.JOB_NAME}",
          body: "Pipeline completada com: ${currentBuild.currentResult}\n" +
                "Detalhes da execução da pipeline: ${env.BUILD_URL}\n\n${env.EMAIL_ASSINATURA}\n\n\n${env.EMAIL_RODAPE}"

      slackSend(color: "danger", message: "Pipeline #${env.BUILD_NUMBER} ${currentBuild.currentResult} em ${env.JOB_NAME} (<${env.BUILD_URL}|Mais info...>)")
    }
    unstable {
      echo 'Processo de pipeline possui estabilidade.'
    }
    changed {
      echo 'SUCESSO no processo de pipeline anteriormente falhado.'
    }
  }
}

def slack_msg()
{
  def JOB_NAME = env.JOB_NAME
  def BUILD_ID = env.BUILD_ID
  def JENKINS_MSG = "Pipeline [${env.JOB_NAME}] finalizada com SUCESSO!\n" +
  "Logs path: ${env.JENKINS_URL}/job/${JOB_NAME}/${BUILD_ID}/consoleText\n" +
  "Quality Gate: ${env.SONAR_URL}/dashboard?id=${env.APP_NAME}"
  return JENKINS_MSG
}
