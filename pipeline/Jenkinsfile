#!/usr/bin/env groovy

pipeline {
  agent {
    kubernetes {
      yamlFile './kubernetes/agent/jenkins-agent-pod-k8s.yaml'
      inheritFrom 'inbound'
      idleMinutes 5
      defaultContainer 'php8'
    }
  }
  options {
    timestamps()
    timeout(time: 2, unit: 'HOURS')
    parallelsAlwaysFailFast()
    rateLimitBuilds(throttle: [count: 3, durationName: 'minute', userBoost: false])
    buildDiscarder(logRotator(numToKeepStr: '100'))
    ansiColor('xterm')
  }
  triggers { // crontab.guru
    // Pipeline com gatilho semanal ativo e via GitLab Pushs.
    cron('0 0 * * 1') 
  }
  environment {
    APP_NAME = "app-3s"
    APP_VERSION = "1.0.0"
    APP_NAMESPACE = "app-3s"
    DOCKER_TAG = "${env.GIT_BRANCH.split('/')[-1]}"
    DOCKER_IMAGE = "dti-registro.unilab.edu.br/unilab/${APP_NAME}"
    BUILD_NUMBER = "${env.BUILD_NUMBER}"
    DOCKER_BUILDKIT = 1
    TF_IN_AUTOMATION = 1
    THREAD_COUNT = 6
    SEMGREP_TIMEOUT = "300"
    recipientEmails = "erivandoramos@unilab.edu.br"
  }
  stages {
    stage('Iniciando CI/CD') {
      steps {
        milestone(ordinal: null, label: "Milestone: Setup")
        script {
          currentBuild.displayName = "$BUILD_DISPLAY_NAME (${GIT_COMMIT.take(8)})"
          workspace = "$env.WORKSPACE"
        }
        // executar alguns comandos shell para configurar outros detalhes.
        sh '''
          set -x
          # Instala pacotes
          apt-get update && apt-get install -y --no-install-recommends \
            curl \
            wget \
            unzip \
            rsync \
            && rm -rf /var/lib/apt/lists/*

          # Instala kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" 
          curl -LO "https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256"
          echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check
          chmod u+x ./kubectl
          install -o root -g root -m 0755 kubectl /usr/bin/kubectl
          kubectl version --client -ojson

          # Instala Vault
          curl -o vault.zip -k https://releases.hashicorp.com/vault/1.12.1/vault_1.12.1_linux_amd64.zip; yes | unzip vault.zip

          # Instala compose
          curl -sS https://getcomposer.org/installer -o composer-setup.php 
          php composer-setup.php --install-dir=/usr/local/bin --filename=composer 
          chown -R www-data:www-data /usr/local/bin/composer 
        '''
        sh '''
          # Obtem o vendor
          composer create-project laravel/laravel --prefer-dist /tmp/proj-laravel
          ls -la /tmp/proj-laravel
          cp -ra source/ /tmp/proj-laravel/
          rsync --progress --recursive -arvPo /tmp/proj-laravel/ source/
          mv source/.env.example source/.env
          ls -la source/
          printenv
        '''
      }
    }
    // stage('SonarQube Analysis') {
    //   steps {
    //     container('maven') {
    //       script {
    //         def scannerHome = tool 'SonarScanner'
    //         withSonarQubeEnv('SonarQube') {
    //           sh "${scannerHome}/bin/sonar-scanner -Dsonar.projectKey=app-3s -Dsonar.sources=source/app3s -Dsonar.exclusions=vendor/** -Dsonar.language=php -Dsonar.sourceEncoding=UTF-8"
    //           sh 'echo "SONAR_AUTH_TOKEN=$SONAR_AUTH_TOKEN" >> target/sonar/report-task.txt'
    //         }
    //         stash includes: "target/sonar/report-task.txt", name: 'sonar-report-task'
    //       }
    //     }
    //   }
    // }
    // stage("Quality Gate") {
    //   steps {
    //     script {
    //       def branchName = env.BRANCH_NAME
    //       def qualitygate = waitForQualityGate()

    //       unstash 'sonar-report-task'
    //       def props = utils.getProperties("target/sonar/report-task.txt")
    //       echo "properties=${props}"
    //       def sonarServerUrl=props.getProperty('serverUrl')
    //       def ceTaskUrl= props.getProperty('ceTaskUrl')
    //       def ceTask
    //       def URL url = new URL(ceTaskUrl)
    //       if (branchName == "main") {
    //         echo "Ignore na  branch 'develop'."
    //       }
    //       else {
    //       timeout(time: 5, unit: 'MINUTES') {
    //         if (!(qualitygate.status == 'OK' || qualitygate.status == 'WARN')) {
    //           error "Pipeline abortada devido a falha em Quality Gate: ${qualitygate.status}"
    //           waitForQualityGate abortPipeline: true
    //         } 
    //       }
    //       }
    //     }
    //   }
    // }

    stage('SonarQube Analysis') {
      steps {
        container('maven') {
          script {
            /*
            sh '''
              set -x
              openssl s_client -showcerts -connect k8s.unilab.edu.br:443 </dev/null 2>/dev/null|openssl x509 -outform PEM > /tmp/ca.crt
              cp /usr/lib/jvm/msopenjdk-17-amd64/lib/security/cacerts /tmp/keystore.jks
              /usr/lib/jvm/msopenjdk-17-amd64/bin/keytool -import -trustcacerts -alias caCert -file /tmp/ca.crt -keystore /tmp/keystore.jks -noprompt -storepass changeit >/dev/null
              cp /tmp/keystore.jks /usr/lib/jvm/msopenjdk-17-amd64/lib/security/cacerts
            '''
            */
            
            def scannerHome = tool 'SonarScanner'
            def branchName = env.BRANCH_NAME
            env.SONAR_TOKEN = "sqa_4ff6cc386c6eb1271ba371e32469000c10203f51"

            withSonarQubeEnv('SonarQube') {
                sh "${scannerHome}/bin/sonar-scanner -Dsonar.projectKey=app-3s -Dsonar.sources=source/app3s -Dsonar.exclusions=vendor/** -Dsonar.language=php -Dsonar.sourceEncoding=UTF-8 -Dsonar.login=${env.SONAR_TOKEN}"
                sh "cat .scannerwork/report-task.txt"
                def props = readProperties  file: '.scannerwork/report-task.txt'
                echo "properties=${props}"
                def sonarServerUrl=props['serverUrl']
                def ceTaskUrl= props['ceTaskUrl']
                def ceTask
                timeout(time: 2, unit: 'MINUTES') {
                    waitUntil {
                        def response = httpRequest ceTaskUrl
                        ceTask = readJSON text: response.content
                        echo ceTask.toString()
                        return "SUCCESS".equals(ceTask["task"]["status"])
                    }
                }
                def response2 = httpRequest url : sonarServerUrl + "/api/qualitygates/project_status?analysisId=" + ceTask["task"]["analysisId"], authentication: 'sonar-admin'
                def qualitygate =  readJSON text: response2.content
                echo qualitygate.toString()

                if (branchName == "main") {
                  echo "Ignore na branch 'develop'."
                }
                else {
                  if ("ERROR".equals(qualitygate["projectStatus"]["status"]) || !(qualitygate.status == 'OK' || qualitygate.status == 'WARN')) {
                      error "Pipeline abortada devido a falha em Quality Gate: ${qualitygate.status}"
                      waitForQualityGate abortPipeline: true
                  }
                }
            }
            
          }
        }
      }
    }
    stage('Testes') {
      steps {
        sh 'cd source/ && php artisan key:generate && php artisan make:test tests/BasicTest && composer dump-autoload'
        sh 'source/vendor/bin/phpunit --no-configuration --no-extensions source/tests/'
      }
    }
    stage('Build Image Container') {
      steps {
        container('docker') {
          milestone(ordinal: null, label: "Milestone: Docker Build")
          timeout(time: 60, unit: 'MINUTES') {
            sh "docker build -f ./Dockerfile --target production -t '$DOCKER_IMAGE:$DOCKER_TAG' --build-arg 'VERSION=$APP_VERSION COMMIT_SHA=$GIT_COMMIT BUILDKIT_INLINE_CACHE=1' --no-cache ."
          }
        }
      }
    }
    stage('Obter segredos do Vault') {
      steps {
        withCredentials([
          string(credentialsId: 'role-harbor', variable: 'ROLE_ID'),
          string(credentialsId: 'token-admin', variable: 'VAULT_TOKEN')
        ]) {
          script {
            env.VAULT_ADDR = "https://dti-vault.unilab.edu.br"
            env.SECRET_ID = sh(script: './vault write -tls-skip-verify -field=secret_id -f auth/approle/role/harbor-role/secret-id', returnStdout: true).trim()
            env.VAULT_TOKEN = sh(script: './vault write -tls-skip-verify -field=token auth/approle/login role_id=${ROLE_ID} secret_id=${SECRET_ID}', returnStdout: true).trim()
            env.HARBOR_USERNAME = sh(script: './vault kv get -tls-skip-verify -field=usuario secret/harbor/config', returnStdout: true).trim()
            env.HARBOR_PASSWORD = sh(script: './vault kv get -tls-skip-verify -field=senha secret/harbor/config', returnStdout: true).trim()
          }
        }
      }
    }
    stage('Push Image Container') {
      steps {
        container('docker') { 
          milestone(ordinal: null, label: "Milestone: Docker Push")
          timeout(time: 15, unit: 'MINUTES') {
            sh """
              echo \${HARBOR_PASSWORD} | docker login --username \${HARBOR_USERNAME} --password-stdin https://dti-registro.unilab.edu.br
              unset HARBOR_PASSWORD
              docker push \${DOCKER_IMAGE}:\${DOCKER_TAG}
            """
          }
        }
      }
    }
    stage('Deploy no Kubernetes') {
      steps {
        sh "sed -i 's/:latest/:${env.DOCKER_TAG}/' ./kubernetes/deployment-3s.yaml"
        sh 'cat ./kubernetes/deployment-3s.yaml'
        withKubeConfig([credentialsId: 'kubeconfig-c1', serverUrl: 'https://dti-k8s-c1.unilab.edu.br:6443']) {
          /*
          Teoricamente --record não é obrigatório, porém, tecnicamente torna-se obrigatório para garantir que as 
          alterações deixem um rastro de auditoria rudimentar e cumpram o processo SRE e a cultura DevOps.
          Exemplo de uso: kubectl rollout history -n docker deployment.apps/docker
          Nota: Quando --record não é sinalizador, na tabela, CHANGE-CAUSE estará apenas <none>
          */
          script {
            sh '''
              set -x
              echo "Verifica deploy ativo e exclui."
              kubectl get deployment $APP_NAME -n $APP_NAMESPACE >/dev/null 2>&1 && \
              (kubectl get pods -l $APP_NAME -n $APP_NAMESPACE --no-headers | wc -l) > 0 && \
              kubectl delete pods -l app=$APP_NAME -n $APP_NAMESPACE --force --grace-period=0; \
              kubectl delete deployment $APP_NAME -n $APP_NAMESPACE || echo 'DEPLOYMENT INEXISTENTE!'
              
              echo "Aplica deploy."
              kubectl apply -f ./kubernetes/deployment-3s.yaml --record

              echo "Lista de recursos."
              kubectl get all,ing -n $APP_NAMESPACE -o wide
            '''
            /*
            sh '''
              set -x
              echo "Verifica deploy ativo e exclui."
              kubectl get deployment postgres -n postgres-3s >/dev/null 2>&1 && \
              (kubectl get pods -l postgres -n postgres-3s --no-headers | wc -l) > 0 && \
              kubectl delete pods -l app=postgres -n postgres-3s --force --grace-period=0; \
              kubectl delete deployment postgres -n postgres-3s || echo 'DEPLOYMENT INEXISTENTE!'

              echo "Aplica deploy."
              kubectl apply -f ./kubernetes/statefulSet-postgres-3s.yaml --record

              echo "Lista de recursos."
              kubectl get all,ing -n postgres-3s -o wide
            '''
            */
            env.APP_URI = sh(script: 'kubectl get ingress app-3s -n app-3s -o jsonpath="{.spec.rules[0].host}" | sed "s/^/http:\\/\\//"', returnStdout: true).trim()
          }
        }
      }
    }
  }
  post{
    always {
      echo 'Processo de pipeline finalizado.'
    }
    success {
      echo 'Processo de pipeline BEM-SUCEDIDO.'
      mail to: "${recipientEmails}",
      subject: "Pipeline #${env.BUILD_NUMBER} - ${env.JOB_NAME}",
      body: "Pipeline completada com: ${currentBuild.currentResult}\n" +
            "Detalhes da execução da pipeline em: ${env.BUILD_URL}\n" +
            "Detalhes do teste de qualidade em: http://dti-sonar.unilab.edu.br/dashboard?id=${env.APP_NAME}\n" +
            "Endpoint do serviço: ${env.APP_URI}\n\n${env.EMAIL_ASSINATURA}\n\n\n${env.EMAIL_RODAPE}"
    }
    failure {
      echo 'Processo de pipeline executado com falha.'
    }
    unstable {
      echo 'Processo de pipeline possui estabilidade.'
    }
    changed {
      echo 'SUCESSO no processo de pipeline anteriormente falhado.'
    }
  }
}
